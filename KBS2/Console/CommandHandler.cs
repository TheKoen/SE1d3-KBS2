using System;
using System.Collections.Generic;
using System.Linq;
using KBS2.Console.Commands;
using KBS2.Exceptions;
using KBS2.Util;

namespace KBS2.Console
{
    public static class CommandHandler
    {
        public static event EventHandler<object> CommandRan;

        // List of commands that the console can call
        private static readonly List<Type> CommandList = new List<Type>();
        // List of properties that can be modified using console commands
        private static readonly Dictionary<string, Property> PropertyList = new Dictionary<string, Property>();

        /// <summary>
        /// Resets the list of properties
        /// </summary>
        public static void ResetProperties()
        {
            PropertyList.Clear();
        }

        /// <summary>
        /// Registers an <see cref="ICommand"/> to the <see cref="CommandHandler"/> for future use
        /// </summary>
        /// <param name="command"><see cref="ICommand"/> to be ran</param>
        public static void RegisterCommand(Type command)
        {
            if (!typeof(ICommand).IsAssignableFrom(command))
                throw new TypeMismatchException("Parameter \"command\" must implement ICommand");
            
            var attributes = CommandList.Select(c =>
                (CommandMetadataAttribute) Attribute.GetCustomAttribute(c,
                    typeof(CommandMetadataAttribute))).ToList();
            var thisAttribute =
                (CommandMetadataAttribute) Attribute.GetCustomAttribute(command,
                    typeof(CommandMetadataAttribute));
            
            attributes.ForEach(attribute =>
            {
                if (thisAttribute.Key == attribute.Key || thisAttribute.Aliases.Contains(attribute.Key))
                    throw new KeyExistsException($"Command \"{command.Name}\" conflicts with Key \"{attribute.Key}\"");
                attribute.Aliases.ToList().ForEach(alias =>
                {
                    if (thisAttribute.Key == alias || thisAttribute.Aliases.Contains(alias))
                        throw new KeyExistsException($"Command \"{command.Name}\" conflicts with Alias \"{alias}\"");
                });
            });

            CommandList.Add(command);
        }

        /// <summary>
        /// Registers a <see cref="Property"/> to the <see cref="CommandHandler"/> for future use
        /// </summary>
        /// <param name="name">Name of the <see cref="Property"/></param>
        /// <param name="property"><see cref="Property"/> to be stored</param>
        public static void RegisterProperty(string name, ref Property property)
        {
            if (PropertyList.ContainsKey(name)) throw new KeyExistsException($"Property \"{name}\" already exists");

            PropertyList.Add(name, property);
        }

        /// <summary>
        /// Gets the name of every registered <see cref="ICommand"/>
        /// </summary>
        /// <returns><see cref="List{String}"/> of names</returns>
        public static List<string> GetCommandNames()
        {
            return CommandList.Select(c =>
                ((CommandMetadataAttribute) Attribute.GetCustomAttribute(c, typeof(CommandMetadataAttribute))).Key
                ).ToList();
        }

        /// <summary>
        /// Gets every registered <see cref="ICommand"/>
        /// </summary>
        /// <returns><see cref="List{Type}"/> of commands</returns>
        public static IEnumerable<Type> GetCommands()
        {
            return CommandList;
        }

        /// <summary>
        /// Gets the name of every registered <see cref="Property"/>
        /// </summary>
        /// <returns><see cref="Dictionary{String,Property}"/> of properties</returns>
        public static Dictionary<string, Property> GetProperties()
        {
            return PropertyList;
        }

        /// <summary>
        /// Runs a <see cref="ICommand"/>
        /// </summary>
        /// <param name="name">Name of the <see cref="ICommand"/> to run</param>
        /// <param name="args">Arguments for the <see cref="ICommand"/></param>
        /// <returns>Output generated by the <see cref="ICommand"/></returns>
        public static IEnumerable<char> RunCommand(string name, params string[] args)
        {
            var commands = CommandList.Where(c =>
            {
                var attribute =
                    (CommandMetadataAttribute) Attribute.GetCustomAttribute(c,
                        typeof(CommandMetadataAttribute));
                return attribute.Aliases.Contains(name) || attribute.Key == name;
            }).ToList();
            if (commands.Count < 1) throw new UnknownCommandException($"Unknown command \"{name}\"");
            if (commands.Count > 1) throw new Exception("There should never be multiple commands with the same key or aliases");
            var command = commands[0];
            
            var result = ((ICommand) Activator.CreateInstance(command)).Run(args);
            CommandRan?.Invoke(command, result);
            return result;
        }

        /// <summary>
        /// Modifies a <see cref="Property"/>
        /// </summary>
        /// <param name="name">Name of the <see cref="Property"/> to modify</param>
        /// <param name="value">New value for the <see cref="Property"/></param>
        public static void ModifyProperty(string name, object value)
        {
            if (!PropertyList.ContainsKey(name)) throw new KeyNotFoundException($"Property \"{name}\" is not registered");
            
            PropertyList[name].Value = value;
        }


        /// <summary>
        /// Attempts to run an <see cref="ICommand"/> using the given input
        /// </summary>
        /// <param name="input">The input to use</param>
        /// <returns>Output from the command</returns>
        public static IEnumerable<char> HandleInput(string input)
        {
            if (input.Trim().Length == 0)
                throw new EmptyCommandException();
            
            // Separating words in the input
            var segments = input.Trim().Split(' ');

            // Getting the command name and arguments
            var commandName = segments[0].ToLower();
            var args = new string[segments.Length - 1];
            Array.Copy(segments, 1, args, 0, args.Length);
            
            // Running the command
            return RunCommand(commandName, args);
        }
    }
}
