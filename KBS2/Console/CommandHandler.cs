using KBS2.Utilities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using KBS2.Util;

namespace KBS2.Console
{
    public static class CommandHandler
    {
        public static event EventHandler<object> CommandRan;

        // List of commands that the console can call
        private static Dictionary<string, ICommand> commandList = new Dictionary<string, ICommand>();
        // List of properties that can be modified using console commands
        private static Dictionary<string, Property> propertyList = new Dictionary<string, Property>();

        /// <summary>
        /// Registers an <see cref="ICommand"/> to the <see cref="CommandHandler"/> for future use
        /// </summary>
        /// <param name="name">Name of the <see cref="ICommand"/></param>
        /// <param name="command"><see cref="ICommand"/> to be ran</param>
        public static void RegisterCommand(string name, ICommand command)
        {
            if (commandList.ContainsKey(name)) throw new KeyExistsException($"Command \"{name}\" already exists");

            commandList.Add(name, command);
        }

        /// <summary>
        /// Registers a <see cref="Property"/> to the <see cref="CommandHandler"/> for future use
        /// </summary>
        /// <param name="name">Name of the <see cref="Property"/></param>
        /// <param name="property"><see cref="Property"/> to be stored</param>
        public static void RegisterProperty(string name, ref Property property)
        {
            if (propertyList.ContainsKey(name)) throw new KeyExistsException($"Property \"{name}\" already exists");

            propertyList.Add(name, property);
        }

        /// <summary>
        /// Gets the name of every registered <see cref="ICommand"/>
        /// </summary>
        /// <returns><see cref="List{String}"/> of names</returns>
        public static List<string> GetCommandNames()
        {
            return commandList.Select(c => c.Key).ToList();
        }

        /// <summary>
        /// Gets the name of every registered <see cref="Property"/>
        /// </summary>
        /// <returns><see cref="Dictionary{String,Property}"/> of properties</returns>
        public static Dictionary<string, Property> GetProperties()
        {
            return propertyList;
        }

        /// <summary>
        /// Runs a <see cref="ICommand"/>
        /// </summary>
        /// <param name="name">Name of the <see cref="ICommand"/> to run</param>
        /// <param name="args">Arguments for the <see cref="ICommand"/></param>
        /// <returns>Output generated by the <see cref="ICommand"/></returns>
        public static IEnumerable<char> RunCommand(string name, params string[] args)
        {
            if (!commandList.ContainsKey(name)) throw new KeyNotFoundException($"Command \"{name}\" is not registered");

            var result = commandList[name].Run(args);
            CommandRan?.Invoke(commandList[name], result);
            return result;
        }

        /// <summary>
        /// Modifies a <see cref="Property"/>
        /// </summary>
        /// <param name="name">Name of the <see cref="Property"/> to modify</param>
        /// <param name="value">New value for the <see cref="Property"/></param>
        public static void ModifyProperty(string name, object value)
        {
            if (!propertyList.ContainsKey(name)) throw new KeyNotFoundException($"Property \"{name}\" is not registered");
            
            propertyList[name].Value = value;
        }


        /// <summary>
        /// Attempts to run an <see cref="ICommand"/> using the given input
        /// </summary>
        /// <param name="input">The input to use</param>
        /// <returns>Output from the command</returns>
        public static IEnumerable<char> HandleInput(string input)
        {
            if (input.Trim().Length == 0)
                throw new EmptyCommandException();
            
            // Separating words in the input
            var segments = input.Trim().Split(' ');

            // Getting the command name and arguments
            var commandName = segments[0];
            if (!GetCommandNames().Contains(commandName))
                throw new UnknownCommandException($"Unknown command \"{commandName}\"");
            var args = new string[segments.Length - 1];
            Array.Copy(segments, 1, args, 0, args.Length);
            
            // Running the command
            return RunCommand(commandName, args);
        }
    }
}
